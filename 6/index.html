<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CS 180: Final Project - Albert Wang</title>
  <style>
    body {
      text-align: center;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    main {
      display: inline-block;
      max-width: 800px;
      margin: 2rem auto;
      text-align: left;
    }
    h1, h2, h3, h4 {
      text-align: center;
    }
    p, ul, li {
      line-height: 1.6;
    }
    img {
      display: block;
      margin: 1rem auto;
      max-width: 100%;
      height: auto;
    }
    .large-img {
        max-width: 150%;
        display: block;
        margin: 1rem auto;
        position: relative;
        left: 50%;
        transform: translateX(-50%);
}
    a {
      color: blue;
      text-decoration: underline;
    }
    ul {
      list-style-type: disc;
      margin-left: 2rem;
    }
  </style>
</head>
<body>
<main>
  <h1>CS 180: Final Project</h1>
  <h2>Albert Wang</h2>

  <p>For the Final Project, there will be two separate subprojects: Lightfield Camera and Gradient Domain Fusion</p>

  <hr>

  <h3>Lightfield Camera</h3>
  <p>
    This project explores how lightfield data can be processed to simulate visual effects like depth refocusing and aperture adjustment. Using a dataset of sub-aperture images arranged in a 17x17 grid, we demonstrate how simple image manipulations like shifting and averaging allow us to produce different effects on the overall image. This lightfield data is taken from 
    <a href="http://lightfield.stanford.edu/lfs.html" target="_blank">Stanford's Light Field Archive</a>.
  </p>

  <h4>Part 1: Depth Refocusing</h4>
  <p>
    Depth refocusing leverages the variation in how objects appear across the lightfield grid based on their distance from the camera. Objects closer to the camera shift more significantly between images compared to distant objects when the camera's optical axis remains unchanged. 
  </p>
  <p>
    To refocus: Each sub-aperture image (u,v) is shifted by 
    <em>C &times; (v - v<sub>c</sub>, u - u<sub>c</sub>)</em>, where <em>(u<sub>c</sub>, v<sub>c</sub>)</em> is the center image coordinate. 
    These shifted images are averaged together, creating a new image focused at a specific depth determined by the constant <em>C</em>.  
    I used <em>C</em> ranging from -2 to 1.6 to generate the GIFs below. 
    As <em>C</em> changes, the apparent focus plane shifts, creating a refocusing effect.
  </p>
  <img src="media/chess_refocus.gif" alt="Chess set depth refocus GIF">
  <img src="media/lego_refocus.gif" alt="Lego set depth refocus GIF">

  <h4>Part 2: Aperture Adjustment</h4>
  <p>
    We can simulate readjusting the aperture by averaging different subsets of images in the dataset. Aperture adjustment simulates changes in the camera's aperture size by controlling how many images from the lightfield are averaged. Larger apertures result in more focused images at a specific depth, while smaller apertures create a broader focus.
  </p>
  <p>
    To adjust the aperture, A radius <em>r</em> defines the maximum allowable distance from the center image for sub-aperture inclusion. Images within this radius are shifted using the same method as depth refocusing and then averaged.
  </p>
   <p> Here is the GIF is generated by using <em>r</em> from range 0 to 15, with a constant <em>C</em> value of -0.15. The result shows the gradual effect of increasing aperture size on focus depth.</p>

  <img src="media/chess_aperture.gif" alt="Chess set aperture adjustment GIF">
  <img src="media/lego_aperture.gif" alt="Lego set aperture adjustment GIF">

  <h4>Summary</h4>
  <p>
    This project helped me understand how lightfields capture rich information about light in a scene, enabling the simulation of camera effects like adjusting focus and aperture. It was fascinating to see how simple operations created multiple different effects.
  </p>

  <hr>

  <h3>Gradient Domain Fusion</h3>
  <p>
    This project explores gradient-domain image processing, a powerful technique for blending images together. Unlike in project 2, which focused on pixel intensity, this project focuses on matching gradients.
  </p>

  <h4>Part 1: Toy Problem</h4>
  <p>
    Before implementing Poisson Blending, we tackled a toy problem to verify our understanding of gradient reconstruction. The objective was to reconstruct an image using only its gradients in the x and y directions and a single known pixel value.
  </p>
  <ul>
    <li>
      <strong>Gradient Matching:</strong> The x and y gradients of the reconstructed image <em>v(x, y)</em> were constrained to match the gradients of the original image <em>s(x, y)</em>:
This involves minimizing ( v(x+1,y) - v(x,y) - [s(x+1,y) - s(x,y)] )<sup>2</sup> (x-gradient)  
      and minimizing ( v(x,y+1) - v(x,y) - [s(x,y+1) - s(x,y)] )<sup>2</sup> (y-gradient)
    </li>
    <li>
      <strong>Intensity Constraint:</strong> To ensure a unique solution, we added a constraint to fix the intensity of the top-left pixel:

      Minimize ( v(1,1) - s(1,1) )<sup>2</sup>
    </li>
    <li>
      <strong>System Setup:</strong> These constraints were combined into a sparse linear system of equations, represented in the form <em>Av = b</em>, where:
      <ul>
        <li><em>A</em>: Sparse matrix encoding the gradient constraints</li>
        <li><em>v</em>: The flattened array of the reconstructed image</li>
        <li><em>b</em>: Gradient values derived from the source image</li>
      </ul>
    </li>
    <li>
      <strong>Solution:</strong> Using least squares, the system was solved to compute <em>v</em>, which was then reshaped back into the reconstructed image. The reconstructed image closely matched the original, confirming the validity of the approach.
    </li>
  </ul>

  <p>Here is the original toy image and the reconstructed image:</p>
  <img src="media/originaltoy.png" alt="Original toy image">
  <img src="media/reconstructedtoy.png" alt="Reconstructed toy image">
  <p>The max error between the two images is 0.0010002051356807207.</p>

  <h4>Part 2: Poisson Blending</h4>
  <p>
    Poisson Blending enables seamless blending of a source image region (e.g., an object) into a target image (e.g., a background) by preserving the gradients of the source region while matching the intensities of the target region around the boundary. The process follows these steps:
  </p>
  <ul>
    <li>
      <strong>Region Selection:</strong> Define the source region and its placement on the target image. This is done using a polygonal mask for the source image and an insertion point for the target.
    </li>
    <li>
      <strong>Gradient Matching:</strong> Solve for the pixel intensities in the source region by enforcing that the gradients in the blended result closely match the source gradients, while maintaining consistency with the target image outside the selected region. Mathematically, the optimization problem was defined as:
      <br>
      <img src="media/eq1.png" alt="Equation 1">
    </li>
    <li>
      <strong>Optimization:</strong> Represent the problem as a sparse system of linear equations (<em>Av = b</em>), where <em>A</em> enforces gradient constraints and <em>b</em> captures known intensity values. The system is solved using sparse linear solvers.
    </li>
    
  </ul>

  <p>Here are some results:</p>
  <img src="media/poisson1.png" alt="Poisson blending result 1">
  <img src="media/poisson2.png" alt="Poisson blending result 2">
  <img src="media/poisson3.png" alt="Poisson blending result 3">
  <p>My favorite result, which shows Goku charging up a Smash Ball:</p>
  <img src="media/poisson4.png" alt="Poisson blending result 4 - Goku with Smash Ball">

  <h4>Bells and Whistles: Mixed Gradients</h4>
  <p>
    Mixed Gradients is similar to Poisson blending, but we use the gradient in source or target with the larger magnitude as the guide, rather than always using the source gradient:
  </p>
  <img src="media/eq2.png" alt="Equation 2">
  <p>
    Here "<em>d<sub>ij</sub></em>" is the value of the gradient from the source or the target image with larger magnitude. Specifically, if |s<sub>i</sub> - s<sub>j</sub>| > |t<sub>i</sub> - t<sub>j</sub>|, then d<sub>ij</sub> = s<sub>i</sub> - s<sub>j</sub>; else d<sub>ij</sub> = t<sub>i</sub> - t<sub>j</sub>. This ensures that the gradients in the blended result maintain the most visually significant changes, whether from the source or the target.
  </p>
  <p>Here's the result of using mixed blending:</p>
  <img src="media/mixed.png" alt="Mixed gradients result" class="large-img">

  <h4>Reflection</h4>
  <p>
    I was able to create some really cool blends by preserving image gradients. The blends were pretty seamless for certain image pairs.
  </p>
</main>
</body>
</html>
